{"ast":null,"code":"import { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { mergeMap } from 'rxjs/operators';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport * as ɵngcc0 from '@angular/core';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS'); // tslint:disable:no-bitwise\n\nclass JwtHelperService {\n  constructor(config = null) {\n    this.tokenGetter = config && config.tokenGetter || function () {};\n  }\n\n  urlBase64Decode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n    switch (output.length % 4) {\n      case 0:\n        {\n          break;\n        }\n\n      case 2:\n        {\n          output += \"==\";\n          break;\n        }\n\n      case 3:\n        {\n          output += \"=\";\n          break;\n        }\n\n      default:\n        {\n          throw new Error(\"Illegal base64url string!\");\n        }\n    }\n\n    return this.b64DecodeUnicode(output);\n  } // credits for decoder goes to https://github.com/atk\n\n\n  b64decode(str) {\n    const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    let output = \"\";\n    str = String(str).replace(/=+$/, \"\");\n\n    if (str.length % 4 === 1) {\n      throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n\n    for ( // initialize result and counters\n    let bc = 0, bs, buffer, idx = 0; // get next character\n    buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;\n    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,\n    // convert the first 8 bits to one ascii character\n    bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n\n    return output;\n  }\n\n  b64DecodeUnicode(str) {\n    return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), c => {\n      return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(\"\"));\n  }\n\n  decodeToken(token = this.tokenGetter()) {\n    if (!token || token === \"\") {\n      return null;\n    }\n\n    const parts = token.split(\".\");\n\n    if (parts.length !== 3) {\n      throw new Error(\"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\");\n    }\n\n    const decoded = this.urlBase64Decode(parts[1]);\n\n    if (!decoded) {\n      throw new Error(\"Cannot decode the token.\");\n    }\n\n    return JSON.parse(decoded);\n  }\n\n  getTokenExpirationDate(token = this.tokenGetter()) {\n    let decoded;\n    decoded = this.decodeToken(token);\n\n    if (!decoded || !decoded.hasOwnProperty(\"exp\")) {\n      return null;\n    }\n\n    const date = new Date(0);\n    date.setUTCSeconds(decoded.exp);\n    return date;\n  }\n\n  isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n    if (!token || token === \"\") {\n      return true;\n    }\n\n    const date = this.getTokenExpirationDate(token);\n    offsetSeconds = offsetSeconds || 0;\n\n    if (date === null) {\n      return false;\n    }\n\n    return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n  }\n\n  getAuthScheme(authScheme, request) {\n    if (typeof authScheme === \"function\") {\n      return authScheme(request);\n    }\n\n    return authScheme;\n  }\n\n}\n\nJwtHelperService.ɵfac = function JwtHelperService_Factory(t) {\n  return new (t || JwtHelperService)(ɵngcc0.ɵɵinject(JWT_OPTIONS));\n};\n\nJwtHelperService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: JwtHelperService,\n  factory: JwtHelperService.ɵfac\n});\n\nJwtHelperService.ctorParameters = () => [{\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [JWT_OPTIONS]\n  }]\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtHelperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [JWT_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\nclass JwtInterceptor {\n  constructor(config, jwtHelper, document) {\n    this.jwtHelper = jwtHelper;\n    this.document = document;\n    this.standardPorts = [\"80\", \"443\"];\n    this.tokenGetter = config.tokenGetter;\n    this.headerName = config.headerName || \"Authorization\";\n    this.authScheme = config.authScheme || config.authScheme === \"\" ? config.authScheme : \"Bearer \";\n    this.allowedDomains = config.allowedDomains || [];\n    this.disallowedRoutes = config.disallowedRoutes || [];\n    this.throwNoTokenError = config.throwNoTokenError || false;\n    this.skipWhenExpired = config.skipWhenExpired;\n  }\n\n  isAllowedDomain(request) {\n    const requestUrl = new URL(request.url, this.document.location.origin); // If the host equals the current window origin,\n    // the domain is allowed by default\n\n    if (requestUrl.host === this.document.location.host) {\n      return true;\n    } // If not the current domain, check the allowed list\n\n\n    const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port) ? \":\" + requestUrl.port : \"\"}`;\n    return this.allowedDomains.findIndex(domain => typeof domain === \"string\" ? domain === hostName : domain instanceof RegExp ? domain.test(hostName) : false) > -1;\n  }\n\n  isDisallowedRoute(request) {\n    const requestedUrl = new URL(request.url, this.document.location.origin);\n    return this.disallowedRoutes.findIndex(route => {\n      if (typeof route === \"string\") {\n        const parsedRoute = new URL(route, this.document.location.origin);\n        return parsedRoute.hostname === requestedUrl.hostname && parsedRoute.pathname === requestedUrl.pathname;\n      }\n\n      if (route instanceof RegExp) {\n        return route.test(request.url);\n      }\n\n      return false;\n    }) > -1;\n  }\n\n  handleInterception(token, request, next) {\n    const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n    let tokenIsExpired = false;\n\n    if (!token && this.throwNoTokenError) {\n      throw new Error(\"Could not get token from tokenGetter function.\");\n    }\n\n    if (this.skipWhenExpired) {\n      tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n    }\n\n    if (token && tokenIsExpired && this.skipWhenExpired) {\n      request = request.clone();\n    } else if (token) {\n      request = request.clone({\n        setHeaders: {\n          [this.headerName]: `${authScheme}${token}`\n        }\n      });\n    }\n\n    return next.handle(request);\n  }\n\n  intercept(request, next) {\n    if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n      return next.handle(request);\n    }\n\n    const token = this.tokenGetter(request);\n\n    if (token instanceof Promise) {\n      return from(token).pipe(mergeMap(asyncToken => {\n        return this.handleInterception(asyncToken, request, next);\n      }));\n    } else {\n      return this.handleInterception(token, request, next);\n    }\n  }\n\n}\n\nJwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) {\n  return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService), ɵngcc0.ɵɵinject(DOCUMENT));\n};\n\nJwtInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: JwtInterceptor,\n  factory: JwtInterceptor.ɵfac\n});\n\nJwtInterceptor.ctorParameters = () => [{\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [JWT_OPTIONS]\n  }]\n}, {\n  type: JwtHelperService\n}, {\n  type: Document,\n  decorators: [{\n    type: Inject,\n    args: [DOCUMENT]\n  }]\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtInterceptor, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [JWT_OPTIONS]\n      }]\n    }, {\n      type: JwtHelperService\n    }, {\n      type: Document,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, null);\n})();\n\nclass JwtModule {\n  constructor(parentModule) {\n    if (parentModule) {\n      throw new Error(\"JwtModule is already loaded. It should only be imported in your application's main module.\");\n    }\n  }\n\n  static forRoot(options) {\n    return {\n      ngModule: JwtModule,\n      providers: [{\n        provide: HTTP_INTERCEPTORS,\n        useClass: JwtInterceptor,\n        multi: true\n      }, options.jwtOptionsProvider || {\n        provide: JWT_OPTIONS,\n        useValue: options.config\n      }, JwtHelperService]\n    };\n  }\n\n}\n\nJwtModule.ɵfac = function JwtModule_Factory(t) {\n  return new (t || JwtModule)(ɵngcc0.ɵɵinject(JwtModule, 12));\n};\n\nJwtModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: JwtModule\n});\nJwtModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\nJwtModule.ctorParameters = () => [{\n  type: JwtModule,\n  decorators: [{\n    type: Optional\n  }, {\n    type: SkipSelf\n  }]\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: JwtModule,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }];\n  }, null);\n})();\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };","map":{"version":3,"sources":["F:/projects/DatingApp/DatingApp-SPA/node_modules/@auth0/angular-jwt/__ivy_ngcc__/fesm2015/auth0-angular-jwt.js"],"names":["InjectionToken","Injectable","Inject","NgModule","Optional","SkipSelf","DOCUMENT","mergeMap","from","HTTP_INTERCEPTORS","ɵngcc0","JWT_OPTIONS","JwtHelperService","constructor","config","tokenGetter","urlBase64Decode","str","output","replace","length","Error","b64DecodeUnicode","b64decode","chars","String","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","decodeURIComponent","Array","prototype","map","call","c","charCodeAt","toString","slice","join","decodeToken","token","parts","split","decoded","JSON","parse","getTokenExpirationDate","hasOwnProperty","date","Date","setUTCSeconds","exp","isTokenExpired","offsetSeconds","valueOf","getAuthScheme","authScheme","request","ɵfac","JwtHelperService_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","factory","ctorParameters","type","undefined","decorators","args","ngDevMode","ɵsetClassMetadata","JwtInterceptor","jwtHelper","document","standardPorts","headerName","allowedDomains","disallowedRoutes","throwNoTokenError","skipWhenExpired","isAllowedDomain","requestUrl","URL","url","location","origin","host","hostName","hostname","port","includes","findIndex","domain","RegExp","test","isDisallowedRoute","requestedUrl","route","parsedRoute","pathname","handleInterception","next","tokenIsExpired","clone","setHeaders","handle","intercept","Promise","pipe","asyncToken","JwtInterceptor_Factory","Document","JwtModule","parentModule","forRoot","options","ngModule","providers","provide","useClass","multi","jwtOptionsProvider","useValue","JwtModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector"],"mappings":"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","sourcesContent":["import { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { mergeMap } from 'rxjs/operators';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport * as ɵngcc0 from '@angular/core';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n\n// tslint:disable:no-bitwise\nclass JwtHelperService {\n    constructor(config = null) {\n        this.tokenGetter = (config && config.tokenGetter) || function () { };\n    }\n    urlBase64Decode(str) {\n        let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        switch (output.length % 4) {\n            case 0: {\n                break;\n            }\n            case 2: {\n                output += \"==\";\n                break;\n            }\n            case 3: {\n                output += \"=\";\n                break;\n            }\n            default: {\n                throw new Error(\"Illegal base64url string!\");\n            }\n        }\n        return this.b64DecodeUnicode(output);\n    }\n    // credits for decoder goes to https://github.com/atk\n    b64decode(str) {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        let output = \"\";\n        str = String(str).replace(/=+$/, \"\");\n        if (str.length % 4 === 1) {\n            throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n        }\n        for (\n        // initialize result and counters\n        let bc = 0, bs, buffer, idx = 0; \n        // get next character\n        (buffer = str.charAt(idx++)); \n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4)\n            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n            : 0) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        return output;\n    }\n    b64DecodeUnicode(str) {\n        return decodeURIComponent(Array.prototype.map\n            .call(this.b64decode(str), (c) => {\n            return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n            .join(\"\"));\n    }\n    decodeToken(token = this.tokenGetter()) {\n        if (!token || token === \"\") {\n            return null;\n        }\n        const parts = token.split(\".\");\n        if (parts.length !== 3) {\n            throw new Error(\"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\");\n        }\n        const decoded = this.urlBase64Decode(parts[1]);\n        if (!decoded) {\n            throw new Error(\"Cannot decode the token.\");\n        }\n        return JSON.parse(decoded);\n    }\n    getTokenExpirationDate(token = this.tokenGetter()) {\n        let decoded;\n        decoded = this.decodeToken(token);\n        if (!decoded || !decoded.hasOwnProperty(\"exp\")) {\n            return null;\n        }\n        const date = new Date(0);\n        date.setUTCSeconds(decoded.exp);\n        return date;\n    }\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n        if (!token || token === \"\") {\n            return true;\n        }\n        const date = this.getTokenExpirationDate(token);\n        offsetSeconds = offsetSeconds || 0;\n        if (date === null) {\n            return false;\n        }\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n    getAuthScheme(authScheme, request) {\n        if (typeof authScheme === \"function\") {\n            return authScheme(request);\n        }\n        return authScheme;\n    }\n}\nJwtHelperService.ɵfac = function JwtHelperService_Factory(t) { return new (t || JwtHelperService)(ɵngcc0.ɵɵinject(JWT_OPTIONS)); };\nJwtHelperService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: JwtHelperService, factory: JwtHelperService.ɵfac });\nJwtHelperService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtHelperService, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [JWT_OPTIONS]\n            }] }]; }, null); })();\n\nclass JwtInterceptor {\n    constructor(config, jwtHelper, document) {\n        this.jwtHelper = jwtHelper;\n        this.document = document;\n        this.standardPorts = [\"80\", \"443\"];\n        this.tokenGetter = config.tokenGetter;\n        this.headerName = config.headerName || \"Authorization\";\n        this.authScheme =\n            config.authScheme || config.authScheme === \"\"\n                ? config.authScheme\n                : \"Bearer \";\n        this.allowedDomains = config.allowedDomains || [];\n        this.disallowedRoutes = config.disallowedRoutes || [];\n        this.throwNoTokenError = config.throwNoTokenError || false;\n        this.skipWhenExpired = config.skipWhenExpired;\n    }\n    isAllowedDomain(request) {\n        const requestUrl = new URL(request.url, this.document.location.origin);\n        // If the host equals the current window origin,\n        // the domain is allowed by default\n        if (requestUrl.host === this.document.location.host) {\n            return true;\n        }\n        // If not the current domain, check the allowed list\n        const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n            ? \":\" + requestUrl.port\n            : \"\"}`;\n        return (this.allowedDomains.findIndex((domain) => typeof domain === \"string\"\n            ? domain === hostName\n            : domain instanceof RegExp\n                ? domain.test(hostName)\n                : false) > -1);\n    }\n    isDisallowedRoute(request) {\n        const requestedUrl = new URL(request.url, this.document.location.origin);\n        return (this.disallowedRoutes.findIndex((route) => {\n            if (typeof route === \"string\") {\n                const parsedRoute = new URL(route, this.document.location.origin);\n                return (parsedRoute.hostname === requestedUrl.hostname &&\n                    parsedRoute.pathname === requestedUrl.pathname);\n            }\n            if (route instanceof RegExp) {\n                return route.test(request.url);\n            }\n            return false;\n        }) > -1);\n    }\n    handleInterception(token, request, next) {\n        const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n        let tokenIsExpired = false;\n        if (!token && this.throwNoTokenError) {\n            throw new Error(\"Could not get token from tokenGetter function.\");\n        }\n        if (this.skipWhenExpired) {\n            tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n        }\n        if (token && tokenIsExpired && this.skipWhenExpired) {\n            request = request.clone();\n        }\n        else if (token) {\n            request = request.clone({\n                setHeaders: {\n                    [this.headerName]: `${authScheme}${token}`,\n                },\n            });\n        }\n        return next.handle(request);\n    }\n    intercept(request, next) {\n        if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n            return next.handle(request);\n        }\n        const token = this.tokenGetter(request);\n        if (token instanceof Promise) {\n            return from(token).pipe(mergeMap((asyncToken) => {\n                return this.handleInterception(asyncToken, request, next);\n            }));\n        }\n        else {\n            return this.handleInterception(token, request, next);\n        }\n    }\n}\nJwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) { return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService), ɵngcc0.ɵɵinject(DOCUMENT)); };\nJwtInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: JwtInterceptor, factory: JwtInterceptor.ɵfac });\nJwtInterceptor.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [JWT_OPTIONS,] }] },\n    { type: JwtHelperService },\n    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtInterceptor, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [JWT_OPTIONS]\n            }] }, { type: JwtHelperService }, { type: Document, decorators: [{\n                type: Inject,\n                args: [DOCUMENT]\n            }] }]; }, null); })();\n\nclass JwtModule {\n    constructor(parentModule) {\n        if (parentModule) {\n            throw new Error(\"JwtModule is already loaded. It should only be imported in your application's main module.\");\n        }\n    }\n    static forRoot(options) {\n        return {\n            ngModule: JwtModule,\n            providers: [\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: JwtInterceptor,\n                    multi: true,\n                },\n                options.jwtOptionsProvider || {\n                    provide: JWT_OPTIONS,\n                    useValue: options.config,\n                },\n                JwtHelperService,\n            ],\n        };\n    }\n}\nJwtModule.ɵfac = function JwtModule_Factory(t) { return new (t || JwtModule)(ɵngcc0.ɵɵinject(JwtModule, 12)); };\nJwtModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: JwtModule });\nJwtModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});\nJwtModule.ctorParameters = () => [\n    { type: JwtModule, decorators: [{ type: Optional }, { type: SkipSelf }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JwtModule, [{\n        type: NgModule\n    }], function () { return [{ type: JwtModule, decorators: [{\n                type: Optional\n            }, {\n                type: SkipSelf\n            }] }]; }, null); })();\n\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule };\n\n"]},"metadata":{},"sourceType":"module"}