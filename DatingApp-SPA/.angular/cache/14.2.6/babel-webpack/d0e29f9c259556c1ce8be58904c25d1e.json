{"ast":null,"code":"import { getBsVer } from 'ngx-bootstrap/utils';\nimport { ɵɵdefineInjectable, ɵɵinject, NgZone, RendererFactory2, PLATFORM_ID, Injectable, Inject, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\nimport * as ɵngcc0 from '@angular/core';\nvar MapPlacementInToRL;\n\n(function (MapPlacementInToRL) {\n  MapPlacementInToRL[\"top\"] = \"top\";\n  MapPlacementInToRL[\"bottom\"] = \"bottom\";\n  MapPlacementInToRL[\"left\"] = \"left\";\n  MapPlacementInToRL[\"right\"] = \"right\";\n  MapPlacementInToRL[\"auto\"] = \"auto\";\n  MapPlacementInToRL[\"end\"] = \"right\";\n  MapPlacementInToRL[\"start\"] = \"left\";\n  MapPlacementInToRL[\"top left\"] = \"top left\";\n  MapPlacementInToRL[\"top right\"] = \"top right\";\n  MapPlacementInToRL[\"right top\"] = \"right top\";\n  MapPlacementInToRL[\"right bottom\"] = \"right bottom\";\n  MapPlacementInToRL[\"bottom right\"] = \"bottom right\";\n  MapPlacementInToRL[\"bottom left\"] = \"bottom left\";\n  MapPlacementInToRL[\"left bottom\"] = \"left bottom\";\n  MapPlacementInToRL[\"left top\"] = \"left top\";\n  MapPlacementInToRL[\"top start\"] = \"top left\";\n  MapPlacementInToRL[\"top end\"] = \"top right\";\n  MapPlacementInToRL[\"end top\"] = \"right top\";\n  MapPlacementInToRL[\"end bottom\"] = \"right bottom\";\n  MapPlacementInToRL[\"bottom end\"] = \"bottom right\";\n  MapPlacementInToRL[\"bottom start\"] = \"bottom left\";\n  MapPlacementInToRL[\"start bottom\"] = \"start bottom\";\n  MapPlacementInToRL[\"start top\"] = \"left top\";\n})(MapPlacementInToRL || (MapPlacementInToRL = {}));\n\nvar PlacementForBs5;\n\n(function (PlacementForBs5) {\n  PlacementForBs5[\"top\"] = \"top\";\n  PlacementForBs5[\"bottom\"] = \"bottom\";\n  PlacementForBs5[\"left\"] = \"start\";\n  PlacementForBs5[\"right\"] = \"end\";\n  PlacementForBs5[\"auto\"] = \"auto\";\n  PlacementForBs5[\"end\"] = \"end\";\n  PlacementForBs5[\"start\"] = \"start\";\n  PlacementForBs5[\"top left\"] = \"top start\";\n  PlacementForBs5[\"top right\"] = \"top end\";\n  PlacementForBs5[\"right top\"] = \"end top\";\n  PlacementForBs5[\"right bottom\"] = \"end bottom\";\n  PlacementForBs5[\"bottom right\"] = \"bottom end\";\n  PlacementForBs5[\"bottom left\"] = \"bottom start\";\n  PlacementForBs5[\"left bottom\"] = \"start bottom\";\n  PlacementForBs5[\"left top\"] = \"start top\";\n  PlacementForBs5[\"top start\"] = \"top start\";\n  PlacementForBs5[\"top end\"] = \"top end\";\n  PlacementForBs5[\"end top\"] = \"end top\";\n  PlacementForBs5[\"end bottom\"] = \"end bottom\";\n  PlacementForBs5[\"bottom end\"] = \"bottom end\";\n  PlacementForBs5[\"bottom start\"] = \"bottom start\";\n  PlacementForBs5[\"start bottom\"] = \"start bottom\";\n  PlacementForBs5[\"start top\"] = \"start top\";\n})(PlacementForBs5 || (PlacementForBs5 = {}));\n\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  } // NOTE: 1 DOM access here\n\n\n  const window = element.ownerDocument.defaultView;\n  const css = window === null || window === void 0 ? void 0 : window.getComputedStyle(element, null); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n\n  return property ? css && css[property] : css;\n}\n\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n/**\n * Determines if the browser is Internet Explorer\n */\n// todo: valorkin fix and drop IE support :evil:\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst isIE10 = isBrowser && !!(window.MSInputMethodContext && /MSIE 10/.test(navigator.userAgent));\n\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n/**\n * Returns the offset parent of the given element\n */\n\n\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here\n\n  let offsetParent = element === null || element === void 0 ? void 0 : element.offsetParent; // Skip hidden elements which don't have an offsetParent\n\n  let sibling = void 0;\n\n  while (offsetParent === noOffsetParent && element.nextElementSibling && sibling !== element.nextElementSibling) {\n    // todo: valorkin fix\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  } // .offsetParent will return the closest TH, TD or TABLE in case\n\n\n  if (offsetParent && ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n} // todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction isOffsetContainer(element) {\n  const {\n    nodeName\n  } = element;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\n\n\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n/**\n * Finds the offset parent common to the two provided nodes\n */\n\n\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  } // Here we make sure to give as \"start\" the element that comes first in the DOM\n\n\n  const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1; // Get common ancestor container\n\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0); // todo: valorkin fix\n\n  const commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  } // one of the nodes is inside shadowDOM, find which one\n\n\n  const element1root = getRoot(element1);\n\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n/**\n * Finds the first parent of an element that has a transformed property defined\n */\n\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n\n  let el = element.parentElement;\n\n  while ((el === null || el === void 0 ? void 0 : el.parentElement) && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n/**\n * Helper to detect borders of a given element\n */\n\n\nfunction getBordersSize(styles, axis) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles[`border${sideA}Width`]) + parseFloat(styles[`border${sideB}Width`]);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  const _body = body;\n  const _html = html;\n  const _computedStyle = computedStyle;\n  return Math.max(_body[`offset${axis}`], _body[`scroll${axis}`], _html[`client${axis}`], _html[`offset${axis}`], _html[`scroll${axis}`], isIE(10) ? parseInt(_html[`offset${axis}`], 10) + parseInt(_computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) + parseInt(_computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10) : 0);\n}\n\nfunction getWindowSizes(document) {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = isIE(10) ? getComputedStyle(html) : void 0;\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\n\n\nfunction getScroll(element, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\nfunction getClientRect(offsets) {\n  return Object.assign(Object.assign({}, offsets), {\n    right: (offsets.left || 0) + offsets.width,\n    bottom: (offsets.top || 0) + offsets.height\n  });\n}\n/**\n * Tells if a given input is a number\n */\n\n\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(Number(n));\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n/**\n * Get bounding client rect of given element\n */\n\n\nfunction getBoundingClientRect(element) {\n  const rect = element.getBoundingClientRect(); // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n\n  try {\n    if (isIE(10)) {\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n\n      if (rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right)) {\n        rect.top += scrollTop;\n        rect.left += scrollLeft;\n        rect.bottom += scrollTop;\n        rect.right += scrollLeft;\n      }\n    }\n  } catch (e) {\n    return rect;\n  }\n\n  if (!(rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right))) {\n    return rect;\n  }\n\n  const result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  }; // subtract scrollbar size from sizes\n\n  const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\n  const width = (sizes === null || sizes === void 0 ? void 0 : sizes.width) || element.clientWidth || isNumber(rect.right) && isNumber(result.left) && rect.right - result.left || 0;\n  const height = (sizes === null || sizes === void 0 ? void 0 : sizes.height) || element.clientHeight || isNumber(rect.bottom) && isNumber(result.top) && rect.bottom - result.top || 0;\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n/**\n * Returns the parentNode or the host of the element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n/**\n * Returns the scrolling parent of the given element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n\n    case '#document':\n      return element.body;\n\n    default:\n  } // Firefox want us to check `-x` and `-y` variations as well\n\n\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getStyleComputedProperty(element);\n\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\n\n\nfunction includeScroll(rect, element, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n\n  if (isNumber(rect.top)) {\n    rect.top += scrollTop * modifier;\n  }\n\n  if (isNumber(rect.bottom)) {\n    rect.bottom += scrollTop * modifier;\n  }\n\n  if (isNumber(rect.left)) {\n    rect.left += scrollLeft * modifier;\n  }\n\n  if (isNumber(rect.right)) {\n    rect.right += scrollLeft * modifier;\n  }\n\n  return rect;\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n  var _a, _b, _c, _d, _e, _f;\n\n  const isIE10 = isIE(10);\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect = getBoundingClientRect(children);\n  const parentRect = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max((_a = parentRect.top) !== null && _a !== void 0 ? _a : 0, 0);\n    parentRect.left = Math.max((_b = parentRect.left) !== null && _b !== void 0 ? _b : 0, 0);\n  }\n\n  let offsets = getClientRect({\n    top: ((_c = childrenRect.top) !== null && _c !== void 0 ? _c : 0) - ((_d = parentRect.top) !== null && _d !== void 0 ? _d : 0) - borderTopWidth,\n    left: ((_e = childrenRect.left) !== null && _e !== void 0 ? _e : 0) - ((_f = parentRect.left) !== null && _f !== void 0 ? _f : 0) - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n\n  if (!isIE10 && isHTML) {\n    const marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    if (isNumber(offsets.top)) {\n      offsets.top -= borderTopWidth - marginTop;\n    }\n\n    if (isNumber(offsets.bottom)) {\n      offsets.bottom -= borderTopWidth - marginTop;\n    }\n\n    if (isNumber(offsets.left)) {\n      offsets.left -= borderLeftWidth - marginLeft;\n    }\n\n    if (isNumber(offsets.right)) {\n      offsets.right -= borderLeftWidth - marginLeft;\n    } // Attach marginTop and marginLeft because in some circumstances we may need them\n\n\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  const offset = {\n    top: scrollTop - Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.top) + Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.left) + Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.marginLeft),\n    width,\n    height\n  };\n  return getClientRect(offset);\n}\n/**\n * Check if the given element is fixed or is inside a fixed parent\n */\n\n\nfunction isFixed(element) {\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n  // NOTE: 1 DOM access here\n  let boundaries = {\n    top: 0,\n    left: 0\n  };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host); // Handle viewport case\n\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation\n\n    if (offsets && boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const {\n        height,\n        width\n      } = getWindowSizes(target.ownerDocument);\n\n      if (isNumber(boundaries.top) && isNumber(offsets.top) && isNumber(offsets.marginTop)) {\n        boundaries.top += offsets.top - offsets.marginTop;\n      }\n\n      if (isNumber(boundaries.top)) {\n        boundaries.bottom = Number(height) + Number(offsets.top);\n      }\n\n      if (isNumber(boundaries.left) && isNumber(offsets.left) && isNumber(offsets.marginLeft)) {\n        boundaries.left += offsets.left - offsets.marginLeft;\n      }\n\n      if (isNumber(boundaries.top)) {\n        boundaries.right = Number(width) + Number(offsets.left);\n      }\n    } else if (offsets) {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  } // Add paddings\n\n\n  if (isNumber(boundaries.left)) {\n    boundaries.left += padding;\n  }\n\n  if (isNumber(boundaries.top)) {\n    boundaries.top += padding;\n  }\n\n  if (isNumber(boundaries.right)) {\n    boundaries.right -= padding;\n  }\n\n  if (isNumber(boundaries.bottom)) {\n    boundaries.bottom -= padding;\n  }\n\n  return boundaries;\n}\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\n\n\nfunction getArea({\n  width,\n  height\n}) {\n  return width * height;\n}\n\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n  var _a, _b, _c, _d;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n  const rects = {\n    top: {\n      width: (_a = boundaries.width) !== null && _a !== void 0 ? _a : 0,\n      height: refRect.top && boundaries.top ? refRect.top - boundaries.top : 0\n    },\n    right: {\n      width: boundaries.right && refRect.right ? boundaries.right - refRect.right : 0,\n      height: (_b = boundaries.height) !== null && _b !== void 0 ? _b : 0\n    },\n    bottom: {\n      width: (_c = boundaries.width) !== null && _c !== void 0 ? _c : 0,\n      height: boundaries.bottom && refRect.bottom ? boundaries.bottom - refRect.bottom : 0\n    },\n    left: {\n      width: refRect.left && boundaries.left ? refRect.left - boundaries.left : 0,\n      height: (_d = boundaries.height) !== null && _d !== void 0 ? _d : 0\n    }\n  };\n  const sortedAreas = Object.keys(rects).map(key => Object.assign(Object.assign({\n    key\n  }, rects[key]), {\n    area: getArea(rects[key])\n  })).sort((a, b) => b.area - a.area);\n  let filteredAreas = sortedAreas.filter(({\n    width,\n    height\n  }) => {\n    return width >= target.clientWidth && height >= target.clientHeight;\n  });\n  filteredAreas = filteredAreas.filter(position => {\n    return allowedPositions.some(allowedPosition => {\n      return allowedPosition === position.key;\n    });\n  });\n  const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n  const variation = placement.split(' ')[1]; // for tooltip on auto position\n\n  target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${getBsVer().isBs5 ? PlacementForBs5[computedPlacement] : computedPlacement}`);\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n\nfunction getOffsets(data) {\n  var _a, _b, _c, _d;\n\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor((_a = data.offsets.target.left) !== null && _a !== void 0 ? _a : 0),\n    top: Math.round((_b = data.offsets.target.top) !== null && _b !== void 0 ? _b : 0),\n    bottom: Math.round((_c = data.offsets.target.bottom) !== null && _c !== void 0 ? _c : 0),\n    right: Math.floor((_d = data.offsets.target.right) !== null && _d !== void 0 ? _d : 0)\n  };\n}\n/**\n * Get the opposite placement of the given one\n */\n\n\nfunction getOppositePlacement(placement) {\n  const hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n/**\n * Get the opposite placement variation of the given one\n */\n\n\nfunction getOppositeVariation(variation) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n\nconst parse = (value, def = 0) => value ? parseFloat(value) : def;\n\nconst ɵ0 = parse;\n\nfunction getOuterSizes(element) {\n  const window = element.ownerDocument.defaultView;\n  const styles = window === null || window === void 0 ? void 0 : window.getComputedStyle(element);\n  const x = parse(styles === null || styles === void 0 ? void 0 : styles.marginTop) + parse(styles === null || styles === void 0 ? void 0 : styles.marginBottom);\n  const y = parse(styles === null || styles === void 0 ? void 0 : styles.marginLeft) + parse(styles === null || styles === void 0 ? void 0 : styles.marginRight);\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n/**\n * Get offsets to the reference element\n */\n\n\nfunction getReferenceOffsets(target, host, fixedPosition) {\n  const commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n/**\n * Get offsets to the target\n */\n\n\nfunction getTargetOffsets(target, hostOffsets, position) {\n  var _a, _b, _c;\n\n  const placement = position.split(' ')[0]; // Get target node sizes\n\n  const targetRect = getOuterSizes(target); // Add position, width and height to our offsets object\n\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  }; // depending by the target placement we have to compute its offsets slightly differently\n\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n  targetOffsets[mainSide] = ((_a = hostOffsets[mainSide]) !== null && _a !== void 0 ? _a : 0) + hostOffsets[measurement] / 2 - targetRect[measurement] / 2;\n  targetOffsets[secondarySide] = placement === secondarySide ? ((_b = hostOffsets[secondarySide]) !== null && _b !== void 0 ? _b : 0) - targetRect[secondaryMeasurement] : (_c = hostOffsets[getOppositePlacement(secondarySide)]) !== null && _c !== void 0 ? _c : 0;\n  return targetOffsets;\n}\n\nfunction isModifierEnabled(options, modifierName) {\n  var _a;\n\n  return !!((_a = options.modifiers[modifierName]) === null || _a === void 0 ? void 0 : _a.enabled);\n}\n\nconst availablePositions = {\n  top: ['top', 'top start', 'top end'],\n  bottom: ['bottom', 'bottom start', 'bottom end'],\n  start: ['start', 'start top', 'start bottom'],\n  end: ['end', 'end top', 'end bottom']\n};\n\nfunction checkPopoverMargin(placement, checkPosition) {\n  if (!getBsVer().isBs5) {\n    return false;\n  }\n\n  return availablePositions[checkPosition].includes(placement);\n}\n\nfunction checkMargins(placement) {\n  if (!getBsVer().isBs5) {\n    return '';\n  }\n\n  if (checkPopoverMargin(placement, 'end')) {\n    return 'ms-2';\n  }\n\n  if (checkPopoverMargin(placement, 'start')) {\n    return 'me-2';\n  }\n\n  if (checkPopoverMargin(placement, 'top')) {\n    return 'mb-2';\n  }\n\n  if (checkPopoverMargin(placement, 'bottom')) {\n    return 'mt-2';\n  }\n\n  return '';\n}\n\nfunction updateContainerClass(data, renderer) {\n  const target = data.instance.target;\n  let containerClass = target.className;\n  const dataPlacement = getBsVer().isBs5 ? PlacementForBs5[data.placement] : data.placement;\n\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${dataPlacement}`);\n    containerClass = containerClass.replace(/ms-2|me-2|mb-2|mt-2/g, '');\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${dataPlacement}`);\n    containerClass = containerClass.replace(/\\sauto/g, ` ${dataPlacement}`);\n\n    if (containerClass.indexOf('popover') !== -1) {\n      containerClass = containerClass + ' ' + checkMargins(dataPlacement);\n    }\n\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n\n    if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n\n  containerClass = containerClass.replace(/left|right|top|bottom|end|start/g, `${dataPlacement.split(' ')[0]}`);\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n    return;\n  }\n\n  target.className = containerClass;\n}\n\nfunction setStyles(element, styles, renderer) {\n  if (!element || !styles) {\n    return;\n  }\n\n  Object.keys(styles).forEach(prop => {\n    let unit = ''; // add unit if the value is numeric and is one of the following\n\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n\nfunction arrow(data) {\n  var _a, _b, _c, _d, _e, _f;\n\n  let targetOffsets = data.offsets.target; // if arrowElement is a string, suppose it's a CSS selector\n\n  const arrowElement = data.instance.target.querySelector('.arrow'); // if arrowElement is not found, don't run the modifier\n\n  if (!arrowElement) {\n    return data;\n  }\n\n  const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n  const placementVariation = data.placement.split(' ')[1]; // top/left side\n\n  if (((_a = data.offsets.host[opSide]) !== null && _a !== void 0 ? _a : 0) - arrowElementSize < ((_b = targetOffsets[side]) !== null && _b !== void 0 ? _b : 0)) {\n    targetOffsets[side] -= ((_c = targetOffsets[side]) !== null && _c !== void 0 ? _c : 0) - (((_d = data.offsets.host[opSide]) !== null && _d !== void 0 ? _d : 0) - arrowElementSize);\n  } // bottom/right side\n\n\n  if (Number(data.offsets.host[side]) + Number(arrowElementSize) > ((_e = targetOffsets[opSide]) !== null && _e !== void 0 ? _e : 0)) {\n    targetOffsets[side] += Number(data.offsets.host[side]) + Number(arrowElementSize) - Number(targetOffsets[opSide]);\n  }\n\n  targetOffsets = getClientRect(targetOffsets); // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n\n  const css = getStyleComputedProperty(data.instance.target);\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]) || 0;\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]) || 0; // compute center of the target\n\n  let center;\n\n  if (!placementVariation) {\n    center = Number(data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n  } else {\n    const targetBorderRadius = parseFloat(css.borderRadius) || 0;\n    const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n    center = side === placementVariation ? Number(data.offsets.host[side]) + targetSideArrowOffset : Number(data.offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n  }\n\n  let sideValue = center - ((_f = targetOffsets[side]) !== null && _f !== void 0 ? _f : 0) - targetMarginSide - targetBorderSide; // prevent arrowElement from being placed not contiguously to its target\n\n  sideValue = Math.max(Math.min(targetOffsets[len] - (arrowElementSize + 5), sideValue), 0);\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n\n  };\n  data.instance.arrow = arrowElement;\n  return data;\n}\n\nfunction flip(data) {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  if (!isModifierEnabled(data.options, 'flip')) {\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    return data;\n  }\n\n  const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  'viewport', false // positionFixed\n  );\n  let placement = data.placement.split(' ')[0];\n  let variation = data.placement.split(' ')[1] || '';\n  const offsetsHost = data.offsets.host;\n  const target = data.instance.target;\n  const host = data.instance.host;\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  const flipOrder = [placement, adaptivePosition];\n  flipOrder.forEach((step, index) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n\n    if (placement !== step || flipOrder.length === index + 1) {\n      return;\n    }\n\n    placement = data.placement.split(' ')[0]; // using floor because the host offsets may contain decimals we are not going to consider here\n\n    const overlapsRef = placement === 'left' && Math.floor((_a = data.offsets.target.right) !== null && _a !== void 0 ? _a : 0) > Math.floor((_b = data.offsets.host.left) !== null && _b !== void 0 ? _b : 0) || placement === 'right' && Math.floor((_c = data.offsets.target.left) !== null && _c !== void 0 ? _c : 0) < Math.floor((_d = data.offsets.host.right) !== null && _d !== void 0 ? _d : 0) || placement === 'top' && Math.floor((_e = data.offsets.target.bottom) !== null && _e !== void 0 ? _e : 0) > Math.floor((_f = data.offsets.host.top) !== null && _f !== void 0 ? _f : 0) || placement === 'bottom' && Math.floor((_g = data.offsets.target.top) !== null && _g !== void 0 ? _g : 0) < Math.floor((_h = data.offsets.host.bottom) !== null && _h !== void 0 ? _h : 0);\n    const overflowsLeft = Math.floor((_j = data.offsets.target.left) !== null && _j !== void 0 ? _j : 0) < Math.floor((_k = boundaries.left) !== null && _k !== void 0 ? _k : 0);\n    const overflowsRight = Math.floor((_l = data.offsets.target.right) !== null && _l !== void 0 ? _l : 0) > Math.floor((_m = boundaries.right) !== null && _m !== void 0 ? _m : 0);\n    const overflowsTop = Math.floor((_o = data.offsets.target.top) !== null && _o !== void 0 ? _o : 0) < Math.floor((_p = boundaries.top) !== null && _p !== void 0 ? _p : 0);\n    const overflowsBottom = Math.floor((_q = data.offsets.target.bottom) !== null && _q !== void 0 ? _q : 0) > Math.floor((_r = boundaries.bottom) !== null && _r !== void 0 ? _r : 0);\n    const overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required\n\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation = isVertical && variation === 'left' && overflowsLeft || isVertical && variation === 'right' && overflowsRight || !isVertical && variation === 'left' && overflowsTop || !isVertical && variation === 'right' && overflowsBottom;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? ` ${variation}` : '');\n      data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    }\n  });\n  return data;\n}\n\nfunction initData(targetElement, hostElement, position, options) {\n  if (!targetElement || !hostElement) {\n    return;\n  }\n\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom|start|end)*$/) && !position.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/)) {\n    position = 'auto';\n  }\n\n  const placementAuto = !!position.match(/auto/g); // support old placements 'auto left|right|top|bottom'\n\n  let placement = position.match(/auto\\s(left|right|top|bottom|start|end)/) ? position.split(' ')[1] || 'auto' : position; // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n\n  const matches = placement.match(/^(left|right|top|bottom|start|end)* ?(?!\\1)(left|right|top|bottom|start|end)?/);\n\n  if (matches) {\n    placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n  } // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n\n\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n    placement = 'auto';\n  }\n\n  placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n  return {\n    options: options || {\n      modifiers: {}\n    },\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: void 0\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: void 0\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\n\nfunction preventOverflow(data) {\n  var _a;\n\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  } // NOTE: DOM access here\n  // resets the target Offsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n\n\n  const transformProp = 'transform';\n  const targetStyles = data.instance.target.style; // assignment to help minification\n\n  const {\n    top,\n    left,\n    [transformProp]: transform\n  } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n  const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  ((_a = data.options.modifiers.preventOverflow) === null || _a === void 0 ? void 0 : _a.boundariesElement) || 'scrollParent', false // positionFixed\n  ); // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n  const order = ['left', 'right', 'top', 'bottom'];\n  const check = {\n    primary(placement) {\n      var _a, _b, _c, _d;\n\n      let value = data.offsets.target[placement]; // options.escapeWithReference\n\n      if (((_a = data.offsets.target[placement]) !== null && _a !== void 0 ? _a : 0) < ((_b = boundaries[placement]) !== null && _b !== void 0 ? _b : 0)) {\n        value = Math.max((_c = data.offsets.target[placement]) !== null && _c !== void 0 ? _c : 0, (_d = boundaries[placement]) !== null && _d !== void 0 ? _d : 0);\n      }\n\n      return {\n        [placement]: value\n      };\n    },\n\n    secondary(placement) {\n      var _a, _b, _c, _d, _e, _f, _g, _h;\n\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      let value = data.offsets.target[mainSide]; // escapeWithReference\n\n      if (((_a = data.offsets.target[placement]) !== null && _a !== void 0 ? _a : 0) < ((_b = boundaries[placement]) !== null && _b !== void 0 ? _b : 0) && placement !== 'right') {\n        value = Math.min((_c = data.offsets.target[mainSide]) !== null && _c !== void 0 ? _c : 0, ((_d = boundaries[placement]) !== null && _d !== void 0 ? _d : 0) - data.offsets.target.height);\n      }\n\n      if (((_e = data.offsets.target[placement]) !== null && _e !== void 0 ? _e : 0) > ((_f = boundaries[placement]) !== null && _f !== void 0 ? _f : 0) && placement === 'right') {\n        value = Math.min((_g = data.offsets.target[mainSide]) !== null && _g !== void 0 ? _g : 0, ((_h = boundaries[placement]) !== null && _h !== void 0 ? _h : 0) - data.offsets.target.width);\n      }\n\n      return {\n        [mainSide]: value\n      };\n    }\n\n  };\n  order.forEach(placement => {\n    const side = ['left', 'top', 'start'].indexOf(placement) !== -1 ? check['primary'] : check['secondary'];\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), side(placement));\n  });\n  return data;\n}\n\nfunction shift(data) {\n  var _a;\n\n  const placement = data.placement;\n  const basePlacement = placement.split(' ')[0];\n  const shiftVariation = placement.split(' ')[1];\n\n  if (shiftVariation) {\n    const {\n      host,\n      target\n    } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n    const shiftOffsets = {\n      start: {\n        [side]: host[side]\n      },\n      end: {\n        [side]: ((_a = host[side]) !== null && _a !== void 0 ? _a : 0) + host[measurement] - target[measurement]\n      }\n    };\n    data.offsets.target = Object.assign(Object.assign({}, target), {\n      [side]: side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side]\n    });\n  }\n\n  return data;\n}\n\nclass Positioning {\n  position(hostElement, targetElement\n  /*, round = true*/\n  ) {\n    return this.offset(hostElement, targetElement\n    /*, false*/\n    );\n  }\n\n  offset(hostElement, targetElement\n  /*, round = true*/\n  ) {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n\n  positionElements(hostElement, targetElement, position, appendToBody, options) {\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n    const _position = MapPlacementInToRL[position];\n    const data = initData(targetElement, hostElement, _position, options);\n\n    if (!data) {\n      return;\n    }\n\n    return chainOfModifiers.reduce((modifiedData, modifier) => modifier(modifiedData), data);\n  }\n\n}\n\nconst positionService = new Positioning();\n\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n  const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n\n  if (!data) {\n    return;\n  }\n\n  const offsets = getOffsets(data);\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  updateContainerClass(data, renderer);\n}\n\nclass PositioningService {\n  constructor(ngZone, rendererFactory, platformId) {\n    this.update$$ = new Subject();\n    this.positionElements = new Map();\n    this.isDisabled = false;\n\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(() => {\n        this.triggerEvent$ = merge(fromEvent(window, 'scroll', {\n          passive: true\n        }), fromEvent(window, 'resize', {\n          passive: true\n        }), of(0, animationFrameScheduler), this.update$$);\n        this.triggerEvent$.subscribe(() => {\n          if (this.isDisabled) {\n            return;\n          }\n\n          this.positionElements // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          .forEach(positionElement => {\n            positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n          });\n        });\n      });\n    }\n  }\n\n  position(options) {\n    this.addPositionElement(options);\n  }\n\n  get event$() {\n    return this.triggerEvent$;\n  }\n\n  disable() {\n    this.isDisabled = true;\n  }\n\n  enable() {\n    this.isDisabled = false;\n  }\n\n  addPositionElement(options) {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n\n  calcPosition() {\n    this.update$$.next();\n  }\n\n  deletePositionElement(elRef) {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n\n  setOptions(options) {\n    this.options = options;\n  }\n\n}\n\nPositioningService.ɵfac = function PositioningService_Factory(t) {\n  return new (t || PositioningService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(PLATFORM_ID));\n};\n\nPositioningService.ɵprov = ɵɵdefineInjectable({\n  factory: function PositioningService_Factory() {\n    return new PositioningService(ɵɵinject(NgZone), ɵɵinject(RendererFactory2), ɵɵinject(PLATFORM_ID));\n  },\n  token: PositioningService,\n  providedIn: \"root\"\n});\n\nPositioningService.ctorParameters = () => [{\n  type: NgZone\n}, {\n  type: RendererFactory2\n}, {\n  type: Number,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}];\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PositioningService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.RendererFactory2\n    }, {\n      type: Number,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nfunction _getHtmlElement(element) {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element !== null && element !== void 0 ? element : null;\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { PlacementForBs5, Positioning, PositioningService, checkMargins, positionElements };","map":{"version":3,"sources":["F:/projects/DatingApp/DatingApp-SPA/node_modules/ngx-bootstrap/__ivy_ngcc__/positioning/fesm2015/ngx-bootstrap-positioning.js"],"names":["getBsVer","ɵɵdefineInjectable","ɵɵinject","NgZone","RendererFactory2","PLATFORM_ID","Injectable","Inject","ElementRef","isPlatformBrowser","Subject","merge","fromEvent","of","animationFrameScheduler","ɵngcc0","MapPlacementInToRL","PlacementForBs5","getStyleComputedProperty","element","property","nodeType","window","ownerDocument","defaultView","css","getComputedStyle","isBrowser","document","isIE11","MSInputMethodContext","documentMode","isIE10","test","navigator","userAgent","isIE","version","getOffsetParent","documentElement","noOffsetParent","body","offsetParent","sibling","nextElementSibling","nodeName","indexOf","isOffsetContainer","firstElementChild","getRoot","node","parentNode","findCommonOffsetParent","element1","element2","order","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","start","end","range","createRange","setStart","setEnd","commonAncestorContainer","contains","element1root","host","getFixedPositionOffsetParent","parentElement","el","getBordersSize","styles","axis","sideA","sideB","parseFloat","getSize","html","computedStyle","_body","_html","_computedStyle","Math","max","parseInt","getWindowSizes","height","width","getScroll","side","upperSide","scrollingElement","getClientRect","offsets","Object","assign","right","left","bottom","top","isNumeric","n","isNaN","isFinite","Number","isNumber","value","prototype","toString","call","getBoundingClientRect","rect","scrollTop","scrollLeft","e","result","sizes","undefined","clientWidth","clientHeight","horizScrollbar","offsetWidth","vertScrollbar","offsetHeight","getParentNode","getScrollParent","overflow","overflowX","overflowY","String","includeScroll","subtract","modifier","getOffsetRectRelativeToArbitraryNode","children","parent","fixedPosition","_a","_b","_c","_d","_e","_f","isHTML","childrenRect","parentRect","scrollParent","borderTopWidth","borderLeftWidth","marginTop","marginLeft","getViewportOffsetRectRelativeToArtbitraryNode","excludeScroll","relativeOffset","innerWidth","innerHeight","offset","isFixed","getBoundaries","target","padding","boundariesElement","boundaries","boundariesNode","getArea","computeAutoPlacement","placement","refRect","allowedPositions","rects","sortedAreas","keys","map","key","area","sort","a","b","filteredAreas","filter","position","some","allowedPosition","computedPlacement","length","variation","split","className","replace","isBs5","getOffsets","data","floor","round","getOppositePlacement","hash","matched","getOppositeVariation","parse","def","ɵ0","getOuterSizes","x","marginBottom","y","marginRight","getReferenceOffsets","commonOffsetParent","getTargetOffsets","hostOffsets","targetRect","targetOffsets","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","isModifierEnabled","options","modifierName","modifiers","enabled","availablePositions","checkPopoverMargin","checkPosition","includes","checkMargins","updateContainerClass","renderer","instance","containerClass","dataPlacement","placementAuto","setAttribute","setStyles","forEach","prop","unit","setStyle","style","arrow","arrowElement","querySelector","isVertical","len","sideCapitalized","toLowerCase","altSide","opSide","arrowElementSize","placementVariation","targetMarginSide","targetBorderSide","center","targetBorderRadius","borderRadius","targetSideArrowOffset","sideValue","min","flip","offsetsHost","adaptivePosition","flipOrder","step","index","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","overlapsRef","overflowsLeft","overflowsRight","overflowsTop","overflowsBottom","overflowsBoundaries","flippedVariation","initData","targetElement","hostElement","hostElPosition","match","matches","targetOffset","positionFixed","preventOverflow","transformProp","targetStyles","transform","check","primary","secondary","shift","basePlacement","shiftVariation","shiftOffsets","Positioning","positionElements","appendToBody","chainOfModifiers","_position","reduce","modifiedData","positionService","PositioningService","constructor","ngZone","rendererFactory","platformId","update$$","Map","isDisabled","runOutsideAngular","triggerEvent$","passive","subscribe","positionElement","_getHtmlElement","attachment","createRenderer","addPositionElement","event$","disable","enable","set","calcPosition","next","deletePositionElement","elRef","delete","setOptions","ɵfac","PositioningService_Factory","t","ɵprov","factory","token","providedIn","ctorParameters","type","decorators","args","ngDevMode","ɵsetClassMetadata","nativeElement"],"mappings":"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","sourcesContent":["import { getBsVer } from 'ngx-bootstrap/utils';\nimport { ɵɵdefineInjectable, ɵɵinject, NgZone, RendererFactory2, PLATFORM_ID, Injectable, Inject, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n\nimport * as ɵngcc0 from '@angular/core';\nvar MapPlacementInToRL;\n(function (MapPlacementInToRL) {\n    MapPlacementInToRL[\"top\"] = \"top\";\n    MapPlacementInToRL[\"bottom\"] = \"bottom\";\n    MapPlacementInToRL[\"left\"] = \"left\";\n    MapPlacementInToRL[\"right\"] = \"right\";\n    MapPlacementInToRL[\"auto\"] = \"auto\";\n    MapPlacementInToRL[\"end\"] = \"right\";\n    MapPlacementInToRL[\"start\"] = \"left\";\n    MapPlacementInToRL[\"top left\"] = \"top left\";\n    MapPlacementInToRL[\"top right\"] = \"top right\";\n    MapPlacementInToRL[\"right top\"] = \"right top\";\n    MapPlacementInToRL[\"right bottom\"] = \"right bottom\";\n    MapPlacementInToRL[\"bottom right\"] = \"bottom right\";\n    MapPlacementInToRL[\"bottom left\"] = \"bottom left\";\n    MapPlacementInToRL[\"left bottom\"] = \"left bottom\";\n    MapPlacementInToRL[\"left top\"] = \"left top\";\n    MapPlacementInToRL[\"top start\"] = \"top left\";\n    MapPlacementInToRL[\"top end\"] = \"top right\";\n    MapPlacementInToRL[\"end top\"] = \"right top\";\n    MapPlacementInToRL[\"end bottom\"] = \"right bottom\";\n    MapPlacementInToRL[\"bottom end\"] = \"bottom right\";\n    MapPlacementInToRL[\"bottom start\"] = \"bottom left\";\n    MapPlacementInToRL[\"start bottom\"] = \"start bottom\";\n    MapPlacementInToRL[\"start top\"] = \"left top\";\n})(MapPlacementInToRL || (MapPlacementInToRL = {}));\nvar PlacementForBs5;\n(function (PlacementForBs5) {\n    PlacementForBs5[\"top\"] = \"top\";\n    PlacementForBs5[\"bottom\"] = \"bottom\";\n    PlacementForBs5[\"left\"] = \"start\";\n    PlacementForBs5[\"right\"] = \"end\";\n    PlacementForBs5[\"auto\"] = \"auto\";\n    PlacementForBs5[\"end\"] = \"end\";\n    PlacementForBs5[\"start\"] = \"start\";\n    PlacementForBs5[\"top left\"] = \"top start\";\n    PlacementForBs5[\"top right\"] = \"top end\";\n    PlacementForBs5[\"right top\"] = \"end top\";\n    PlacementForBs5[\"right bottom\"] = \"end bottom\";\n    PlacementForBs5[\"bottom right\"] = \"bottom end\";\n    PlacementForBs5[\"bottom left\"] = \"bottom start\";\n    PlacementForBs5[\"left bottom\"] = \"start bottom\";\n    PlacementForBs5[\"left top\"] = \"start top\";\n    PlacementForBs5[\"top start\"] = \"top start\";\n    PlacementForBs5[\"top end\"] = \"top end\";\n    PlacementForBs5[\"end top\"] = \"end top\";\n    PlacementForBs5[\"end bottom\"] = \"end bottom\";\n    PlacementForBs5[\"bottom end\"] = \"bottom end\";\n    PlacementForBs5[\"bottom start\"] = \"bottom start\";\n    PlacementForBs5[\"start bottom\"] = \"start bottom\";\n    PlacementForBs5[\"start top\"] = \"start top\";\n})(PlacementForBs5 || (PlacementForBs5 = {}));\n\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    const window = element.ownerDocument.defaultView;\n    const css = window === null || window === void 0 ? void 0 : window.getComputedStyle(element, null);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return property ? css && css[property] : css;\n}\n\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\n/**\n * Determines if the browser is Internet Explorer\n */\n// todo: valorkin fix and drop IE support :evil:\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nconst isIE10 = isBrowser && !!(window.MSInputMethodContext && /MSIE 10/.test(navigator.userAgent));\nfunction isIE(version) {\n    if (version === 11) {\n        return isIE11;\n    }\n    if (version === 10) {\n        return isIE10;\n    }\n    return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n */\nfunction getOffsetParent(element) {\n    if (!element) {\n        return document.documentElement;\n    }\n    const noOffsetParent = isIE(10) ? document.body : null;\n    // NOTE: 1 DOM access here\n    let offsetParent = element === null || element === void 0 ? void 0 : element.offsetParent;\n    // Skip hidden elements which don't have an offsetParent\n    let sibling = void 0;\n    while (offsetParent === noOffsetParent\n        && element.nextElementSibling\n        && sibling !== element.nextElementSibling) {\n        // todo: valorkin fix\n        sibling = element.nextElementSibling;\n        offsetParent = sibling.offsetParent;\n    }\n    const nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n    }\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    if (offsetParent &&\n        ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n        getStyleComputedProperty(offsetParent, 'position') === 'static') {\n        return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n}\n\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isOffsetContainer(element) {\n    const { nodeName } = element;\n    if (nodeName === 'BODY') {\n        return false;\n    }\n    return (nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element);\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nfunction getRoot(node) {\n    if (node.parentNode !== null) {\n        return getRoot(node.parentNode);\n    }\n    return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n */\nfunction findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n        return document.documentElement;\n    }\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    const start = order ? element1 : element2;\n    const end = order ? element2 : element1;\n    // Get common ancestor container\n    const range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    // todo: valorkin fix\n    const commonAncestorContainer = range.commonAncestorContainer;\n    // Both nodes are inside #document\n    if ((element1 !== commonAncestorContainer &&\n        element2 !== commonAncestorContainer) ||\n        start.contains(end)) {\n        if (isOffsetContainer(commonAncestorContainer)) {\n            return commonAncestorContainer;\n        }\n        return getOffsetParent(commonAncestorContainer);\n    }\n    // one of the nodes is inside shadowDOM, find which one\n    const element1root = getRoot(element1);\n    if (element1root.host) {\n        return findCommonOffsetParent(element1root.host, element2);\n    }\n    else {\n        return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n */\nfunction getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE()) {\n        return document.documentElement;\n    }\n    let el = element.parentElement;\n    while ((el === null || el === void 0 ? void 0 : el.parentElement) && getStyleComputedProperty(el, 'transform') === 'none') {\n        el = el.parentElement;\n    }\n    return el || document.documentElement;\n}\n\n/**\n * Helper to detect borders of a given element\n */\nfunction getBordersSize(styles, axis) {\n    const sideA = axis === 'x' ? 'Left' : 'Top';\n    const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return (parseFloat(styles[`border${sideA}Width`]) +\n        parseFloat(styles[`border${sideB}Width`]));\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n    const _body = body;\n    const _html = html;\n    const _computedStyle = computedStyle;\n    return Math.max(_body[`offset${axis}`], _body[`scroll${axis}`], _html[`client${axis}`], _html[`offset${axis}`], _html[`scroll${axis}`], isIE(10)\n        ? (parseInt(_html[`offset${axis}`], 10) +\n            parseInt(_computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}`], 10) +\n            parseInt(_computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}`], 10))\n        : 0);\n}\nfunction getWindowSizes(document) {\n    const body = document.body;\n    const html = document.documentElement;\n    const computedStyle = isIE(10) ? getComputedStyle(html) : void 0;\n    return {\n        height: getSize('Height', body, html, computedStyle),\n        width: getSize('Width', body, html, computedStyle)\n    };\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nfunction getScroll(element, side = 'top') {\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        const html = element.ownerDocument.documentElement;\n        const scrollingElement = element.ownerDocument.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n}\n\nfunction getClientRect(offsets) {\n    return Object.assign(Object.assign({}, offsets), { right: (offsets.left || 0) + offsets.width, bottom: (offsets.top || 0) + offsets.height });\n}\n\n/**\n * Tells if a given input is a number\n */\nfunction isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(Number(n));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isNumber(value) {\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/**\n * Get bounding client rect of given element\n */\nfunction getBoundingClientRect(element) {\n    const rect = element.getBoundingClientRect();\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    try {\n        if (isIE(10)) {\n            const scrollTop = getScroll(element, 'top');\n            const scrollLeft = getScroll(element, 'left');\n            if (rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right)) {\n                rect.top += scrollTop;\n                rect.left += scrollLeft;\n                rect.bottom += scrollTop;\n                rect.right += scrollLeft;\n            }\n        }\n    }\n    catch (e) {\n        return rect;\n    }\n    if (!(rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right))) {\n        return rect;\n    }\n    const result = {\n        left: rect.left,\n        top: rect.top,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n    // subtract scrollbar size from sizes\n    const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\n    const width = (sizes === null || sizes === void 0 ? void 0 : sizes.width) || element.clientWidth\n        || isNumber(rect.right) && isNumber(result.left) && rect.right - result.left || 0;\n    const height = (sizes === null || sizes === void 0 ? void 0 : sizes.height) || element.clientHeight\n        || isNumber(rect.bottom) && isNumber(result.top) && rect.bottom - result.top || 0;\n    let horizScrollbar = element.offsetWidth - width;\n    let vertScrollbar = element.offsetHeight - height;\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        const styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n        result.width -= horizScrollbar;\n        result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n}\n\n/**\n * Returns the parentNode or the host of the element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n        return document.body;\n    }\n    switch (element.nodeName) {\n        case 'HTML':\n        case 'BODY':\n            return element.ownerDocument.body;\n        case '#document':\n            return element.body;\n        default:\n    }\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n    if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n        return element;\n    }\n    return getScrollParent(getParentNode(element));\n}\n\n/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\nfunction includeScroll(rect, element, subtract = false) {\n    const scrollTop = getScroll(element, 'top');\n    const scrollLeft = getScroll(element, 'left');\n    const modifier = subtract ? -1 : 1;\n    if (isNumber(rect.top)) {\n        rect.top += scrollTop * modifier;\n    }\n    if (isNumber(rect.bottom)) {\n        rect.bottom += scrollTop * modifier;\n    }\n    if (isNumber(rect.left)) {\n        rect.left += scrollLeft * modifier;\n    }\n    if (isNumber(rect.right)) {\n        rect.right += scrollLeft * modifier;\n    }\n    return rect;\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n    var _a, _b, _c, _d, _e, _f;\n    const isIE10 = isIE(10);\n    const isHTML = parent.nodeName === 'HTML';\n    const childrenRect = getBoundingClientRect(children);\n    const parentRect = getBoundingClientRect(parent);\n    const scrollParent = getScrollParent(children);\n    const styles = getStyleComputedProperty(parent);\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n        parentRect.top = Math.max((_a = parentRect.top) !== null && _a !== void 0 ? _a : 0, 0);\n        parentRect.left = Math.max((_b = parentRect.left) !== null && _b !== void 0 ? _b : 0, 0);\n    }\n    let offsets = getClientRect({\n        top: ((_c = childrenRect.top) !== null && _c !== void 0 ? _c : 0) - ((_d = parentRect.top) !== null && _d !== void 0 ? _d : 0) - borderTopWidth,\n        left: ((_e = childrenRect.left) !== null && _e !== void 0 ? _e : 0) - ((_f = parentRect.left) !== null && _f !== void 0 ? _f : 0) - borderLeftWidth,\n        width: childrenRect.width,\n        height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (!isIE10 && isHTML) {\n        const marginTop = parseFloat(styles.marginTop);\n        const marginLeft = parseFloat(styles.marginLeft);\n        if (isNumber(offsets.top)) {\n            offsets.top -= borderTopWidth - marginTop;\n        }\n        if (isNumber(offsets.bottom)) {\n            offsets.bottom -= borderTopWidth - marginTop;\n        }\n        if (isNumber(offsets.left)) {\n            offsets.left -= borderLeftWidth - marginLeft;\n        }\n        if (isNumber(offsets.right)) {\n            offsets.right -= borderLeftWidth - marginLeft;\n        }\n        // Attach marginTop and marginLeft because in some circumstances we may need them\n        offsets.marginTop = marginTop;\n        offsets.marginLeft = marginLeft;\n    }\n    if (isIE10 && !fixedPosition\n        ? parent.contains(scrollParent)\n        : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n        offsets = includeScroll(offsets, parent);\n    }\n    return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n    const html = element.ownerDocument.documentElement;\n    const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    const width = Math.max(html.clientWidth, window.innerWidth || 0);\n    const height = Math.max(html.clientHeight, window.innerHeight || 0);\n    const scrollTop = !excludeScroll ? getScroll(html) : 0;\n    const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    const offset = {\n        top: scrollTop - Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.top) + Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.marginTop),\n        left: scrollLeft - Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.left) + Number(relativeOffset === null || relativeOffset === void 0 ? void 0 : relativeOffset.marginLeft),\n        width,\n        height\n    };\n    return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nfunction isFixed(element) {\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n    // NOTE: 1 DOM access here\n    let boundaries = { top: 0, left: 0 };\n    const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    }\n    else {\n        // Handle other cases based on DOM element used as boundaries\n        let boundariesNode;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(getParentNode(host));\n            if (boundariesNode.nodeName === 'BODY') {\n                boundariesNode = target.ownerDocument.documentElement;\n            }\n        }\n        else if (boundariesElement === 'window') {\n            boundariesNode = target.ownerDocument.documentElement;\n        }\n        else {\n            boundariesNode = boundariesElement;\n        }\n        const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n        // In case of HTML, we need a different computation\n        if (offsets && boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n            const { height, width } = getWindowSizes(target.ownerDocument);\n            if (isNumber(boundaries.top) && isNumber(offsets.top) && isNumber(offsets.marginTop)) {\n                boundaries.top += offsets.top - offsets.marginTop;\n            }\n            if (isNumber(boundaries.top)) {\n                boundaries.bottom = Number(height) + Number(offsets.top);\n            }\n            if (isNumber(boundaries.left) && isNumber(offsets.left) && isNumber(offsets.marginLeft)) {\n                boundaries.left += offsets.left - offsets.marginLeft;\n            }\n            if (isNumber(boundaries.top)) {\n                boundaries.right = Number(width) + Number(offsets.left);\n            }\n        }\n        else if (offsets) {\n            // for all the other DOM elements, this one is good\n            boundaries = offsets;\n        }\n    }\n    // Add paddings\n    if (isNumber(boundaries.left)) {\n        boundaries.left += padding;\n    }\n    if (isNumber(boundaries.top)) {\n        boundaries.top += padding;\n    }\n    if (isNumber(boundaries.right)) {\n        boundaries.right -= padding;\n    }\n    if (isNumber(boundaries.bottom)) {\n        boundaries.bottom -= padding;\n    }\n    return boundaries;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nfunction getArea({ width, height }) {\n    return width * height;\n}\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n    var _a, _b, _c, _d;\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n    const boundaries = getBoundaries(target, host, padding, boundariesElement);\n    const rects = {\n        top: {\n            width: (_a = boundaries.width) !== null && _a !== void 0 ? _a : 0,\n            height: refRect.top && boundaries.top ? refRect.top - boundaries.top : 0\n        },\n        right: {\n            width: boundaries.right && refRect.right ? boundaries.right - refRect.right : 0,\n            height: (_b = boundaries.height) !== null && _b !== void 0 ? _b : 0\n        },\n        bottom: {\n            width: (_c = boundaries.width) !== null && _c !== void 0 ? _c : 0,\n            height: boundaries.bottom && refRect.bottom ? boundaries.bottom - refRect.bottom : 0\n        },\n        left: {\n            width: refRect.left && boundaries.left ? refRect.left - boundaries.left : 0,\n            height: (_d = boundaries.height) !== null && _d !== void 0 ? _d : 0\n        }\n    };\n    const sortedAreas = Object.keys(rects)\n        .map((key) => (Object.assign(Object.assign({ key }, rects[key]), { area: getArea(rects[key]) })))\n        .sort((a, b) => b.area - a.area);\n    let filteredAreas = sortedAreas.filter(({ width, height }) => {\n        return width >= target.clientWidth\n            && height >= target.clientHeight;\n    });\n    filteredAreas = filteredAreas.filter((position) => {\n        return allowedPositions\n            .some((allowedPosition) => {\n            return allowedPosition === position.key;\n        });\n    });\n    const computedPlacement = filteredAreas.length > 0\n        ? filteredAreas[0].key\n        : sortedAreas[0].key;\n    const variation = placement.split(' ')[1];\n    // for tooltip on auto position\n    target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${getBsVer().isBs5 ? PlacementForBs5[computedPlacement] : computedPlacement}`);\n    return computedPlacement + (variation ? `-${variation}` : '');\n}\n\nfunction getOffsets(data) {\n    var _a, _b, _c, _d;\n    return {\n        width: data.offsets.target.width,\n        height: data.offsets.target.height,\n        left: Math.floor((_a = data.offsets.target.left) !== null && _a !== void 0 ? _a : 0),\n        top: Math.round((_b = data.offsets.target.top) !== null && _b !== void 0 ? _b : 0),\n        bottom: Math.round((_c = data.offsets.target.bottom) !== null && _c !== void 0 ? _c : 0),\n        right: Math.floor((_d = data.offsets.target.right) !== null && _d !== void 0 ? _d : 0)\n    };\n}\n\n/**\n * Get the opposite placement of the given one\n */\nfunction getOppositePlacement(placement) {\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n\n/**\n * Get the opposite placement variation of the given one\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'right') {\n        return 'left';\n    }\n    else if (variation === 'left') {\n        return 'right';\n    }\n    return variation;\n}\n\nconst parse = (value, def = 0) => value ? parseFloat(value) : def;\nconst ɵ0 = parse;\nfunction getOuterSizes(element) {\n    const window = element.ownerDocument.defaultView;\n    const styles = window === null || window === void 0 ? void 0 : window.getComputedStyle(element);\n    const x = parse(styles === null || styles === void 0 ? void 0 : styles.marginTop) + parse(styles === null || styles === void 0 ? void 0 : styles.marginBottom);\n    const y = parse(styles === null || styles === void 0 ? void 0 : styles.marginLeft) + parse(styles === null || styles === void 0 ? void 0 : styles.marginRight);\n    return {\n        width: Number(element.offsetWidth) + y,\n        height: Number(element.offsetHeight) + x\n    };\n}\n\n/**\n * Get offsets to the reference element\n */\nfunction getReferenceOffsets(target, host, fixedPosition) {\n    const commonOffsetParent = fixedPosition\n        ? getFixedPositionOffsetParent(target)\n        : findCommonOffsetParent(target, host);\n    return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get offsets to the target\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n    var _a, _b, _c;\n    const placement = position.split(' ')[0];\n    // Get target node sizes\n    const targetRect = getOuterSizes(target);\n    // Add position, width and height to our offsets object\n    const targetOffsets = {\n        width: targetRect.width,\n        height: targetRect.height\n    };\n    // depending by the target placement we have to compute its offsets slightly differently\n    const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    const mainSide = isHoriz ? 'top' : 'left';\n    const secondarySide = isHoriz ? 'left' : 'top';\n    const measurement = isHoriz ? 'height' : 'width';\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    targetOffsets[mainSide] =\n        ((_a = hostOffsets[mainSide]) !== null && _a !== void 0 ? _a : 0) +\n            hostOffsets[measurement] / 2 -\n            targetRect[measurement] / 2;\n    targetOffsets[secondarySide] = placement === secondarySide\n        ? ((_b = hostOffsets[secondarySide]) !== null && _b !== void 0 ? _b : 0) - targetRect[secondaryMeasurement]\n        : (_c = hostOffsets[getOppositePlacement(secondarySide)]) !== null && _c !== void 0 ? _c : 0;\n    return targetOffsets;\n}\n\nfunction isModifierEnabled(options, modifierName) {\n    var _a;\n    return !!((_a = options.modifiers[modifierName]) === null || _a === void 0 ? void 0 : _a.enabled);\n}\n\nconst availablePositions = {\n    top: ['top', 'top start', 'top end'],\n    bottom: ['bottom', 'bottom start', 'bottom end'],\n    start: ['start', 'start top', 'start bottom'],\n    end: ['end', 'end top', 'end bottom']\n};\nfunction checkPopoverMargin(placement, checkPosition) {\n    if (!getBsVer().isBs5) {\n        return false;\n    }\n    return availablePositions[checkPosition].includes(placement);\n}\nfunction checkMargins(placement) {\n    if (!getBsVer().isBs5) {\n        return '';\n    }\n    if (checkPopoverMargin(placement, 'end')) {\n        return 'ms-2';\n    }\n    if (checkPopoverMargin(placement, 'start')) {\n        return 'me-2';\n    }\n    if (checkPopoverMargin(placement, 'top')) {\n        return 'mb-2';\n    }\n    if (checkPopoverMargin(placement, 'bottom')) {\n        return 'mt-2';\n    }\n    return '';\n}\n\nfunction updateContainerClass(data, renderer) {\n    const target = data.instance.target;\n    let containerClass = target.className;\n    const dataPlacement = getBsVer().isBs5 ? PlacementForBs5[data.placement] : data.placement;\n    if (data.placementAuto) {\n        containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${dataPlacement}`);\n        containerClass = containerClass.replace(/ms-2|me-2|mb-2|mt-2/g, '');\n        containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${dataPlacement}`);\n        containerClass = containerClass.replace(/\\sauto/g, ` ${dataPlacement}`);\n        if (containerClass.indexOf('popover') !== -1) {\n            containerClass = containerClass + ' ' + checkMargins(dataPlacement);\n        }\n        if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n            containerClass += ' popover-auto';\n        }\n        if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n            containerClass += ' tooltip-auto';\n        }\n    }\n    containerClass = containerClass.replace(/left|right|top|bottom|end|start/g, `${dataPlacement.split(' ')[0]}`);\n    if (renderer) {\n        renderer.setAttribute(target, 'class', containerClass);\n        return;\n    }\n    target.className = containerClass;\n}\n\nfunction setStyles(element, styles, renderer) {\n    if (!element || !styles) {\n        return;\n    }\n    Object.keys(styles).forEach((prop) => {\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n            isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        if (renderer) {\n            renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        element.style[prop] = String(styles[prop]) + unit;\n    });\n}\n\nfunction arrow(data) {\n    var _a, _b, _c, _d, _e, _f;\n    let targetOffsets = data.offsets.target;\n    // if arrowElement is a string, suppose it's a CSS selector\n    const arrowElement = data.instance.target.querySelector('.arrow');\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n        return data;\n    }\n    const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n    const len = isVertical ? 'height' : 'width';\n    const sideCapitalized = isVertical ? 'Top' : 'Left';\n    const side = sideCapitalized.toLowerCase();\n    const altSide = isVertical ? 'left' : 'top';\n    const opSide = isVertical ? 'bottom' : 'right';\n    const arrowElementSize = getOuterSizes(arrowElement)[len];\n    const placementVariation = data.placement.split(' ')[1];\n    // top/left side\n    if (((_a = data.offsets.host[opSide]) !== null && _a !== void 0 ? _a : 0) - arrowElementSize < ((_b = targetOffsets[side]) !== null && _b !== void 0 ? _b : 0)) {\n        (targetOffsets)[side] -=\n            ((_c = targetOffsets[side]) !== null && _c !== void 0 ? _c : 0) - (((_d = data.offsets.host[opSide]) !== null && _d !== void 0 ? _d : 0) - arrowElementSize);\n    }\n    // bottom/right side\n    if (Number((data).offsets.host[side]) + Number(arrowElementSize) > ((_e = targetOffsets[opSide]) !== null && _e !== void 0 ? _e : 0)) {\n        (targetOffsets)[side] +=\n            Number((data).offsets.host[side]) + Number(arrowElementSize) - Number((targetOffsets)[opSide]);\n    }\n    targetOffsets = getClientRect(targetOffsets);\n    // Compute the sideValue using the updated target offsets\n    // take target margin in account because we don't have this info available\n    const css = getStyleComputedProperty(data.instance.target);\n    const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]) || 0;\n    const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]) || 0;\n    // compute center of the target\n    let center;\n    if (!placementVariation) {\n        center = Number((data).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n    }\n    else {\n        const targetBorderRadius = parseFloat(css.borderRadius) || 0;\n        const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n        center = side === placementVariation ?\n            Number((data).offsets.host[side]) + targetSideArrowOffset :\n            Number((data).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n    }\n    let sideValue = center - ((_f = targetOffsets[side]) !== null && _f !== void 0 ? _f : 0) - targetMarginSide - targetBorderSide;\n    // prevent arrowElement from being placed not contiguously to its target\n    sideValue = Math.max(Math.min(targetOffsets[len] - (arrowElementSize + 5), sideValue), 0);\n    data.offsets.arrow = {\n        [side]: Math.round(sideValue),\n        [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n    };\n    data.instance.arrow = arrowElement;\n    return data;\n}\n\nfunction flip(data) {\n    data.offsets.target = getClientRect(data.offsets.target);\n    if (!isModifierEnabled(data.options, 'flip')) {\n        data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        return data;\n    }\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'viewport', false // positionFixed\n    );\n    let placement = data.placement.split(' ')[0];\n    let variation = data.placement.split(' ')[1] || '';\n    const offsetsHost = data.offsets.host;\n    const target = data.instance.target;\n    const host = data.instance.host;\n    const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n    const flipOrder = [placement, adaptivePosition];\n    flipOrder.forEach((step, index) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        if (placement !== step || flipOrder.length === index + 1) {\n            return;\n        }\n        placement = data.placement.split(' ')[0];\n        // using floor because the host offsets may contain decimals we are not going to consider here\n        const overlapsRef = (placement === 'left' &&\n            Math.floor((_a = data.offsets.target.right) !== null && _a !== void 0 ? _a : 0) > Math.floor((_b = data.offsets.host.left) !== null && _b !== void 0 ? _b : 0)) ||\n            (placement === 'right' &&\n                Math.floor((_c = data.offsets.target.left) !== null && _c !== void 0 ? _c : 0) < Math.floor((_d = data.offsets.host.right) !== null && _d !== void 0 ? _d : 0)) ||\n            (placement === 'top' &&\n                Math.floor((_e = data.offsets.target.bottom) !== null && _e !== void 0 ? _e : 0) > Math.floor((_f = data.offsets.host.top) !== null && _f !== void 0 ? _f : 0)) ||\n            (placement === 'bottom' &&\n                Math.floor((_g = data.offsets.target.top) !== null && _g !== void 0 ? _g : 0) < Math.floor((_h = data.offsets.host.bottom) !== null && _h !== void 0 ? _h : 0));\n        const overflowsLeft = Math.floor((_j = data.offsets.target.left) !== null && _j !== void 0 ? _j : 0) < Math.floor((_k = boundaries.left) !== null && _k !== void 0 ? _k : 0);\n        const overflowsRight = Math.floor((_l = data.offsets.target.right) !== null && _l !== void 0 ? _l : 0) > Math.floor((_m = boundaries.right) !== null && _m !== void 0 ? _m : 0);\n        const overflowsTop = Math.floor((_o = data.offsets.target.top) !== null && _o !== void 0 ? _o : 0) < Math.floor((_p = boundaries.top) !== null && _p !== void 0 ? _p : 0);\n        const overflowsBottom = Math.floor((_q = data.offsets.target.bottom) !== null && _q !== void 0 ? _q : 0) > Math.floor((_r = boundaries.bottom) !== null && _r !== void 0 ? _r : 0);\n        const overflowsBoundaries = (placement === 'left' && overflowsLeft) ||\n            (placement === 'right' && overflowsRight) ||\n            (placement === 'top' && overflowsTop) ||\n            (placement === 'bottom' && overflowsBottom);\n        // flip the variation if required\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        const flippedVariation = ((isVertical && variation === 'left' && overflowsLeft) ||\n            (isVertical && variation === 'right' && overflowsRight) ||\n            (!isVertical && variation === 'left' && overflowsTop) ||\n            (!isVertical && variation === 'right' && overflowsBottom));\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n            data.placement = placement + (variation ? ` ${variation}` : '');\n            data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n        }\n    });\n    return data;\n}\n\nfunction initData(targetElement, hostElement, position, options) {\n    if (!targetElement || !hostElement) {\n        return;\n    }\n    const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n    if (!position.match(/^(auto)*\\s*(left|right|top|bottom|start|end)*$/)\n        && !position.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/)) {\n        position = 'auto';\n    }\n    const placementAuto = !!position.match(/auto/g);\n    // support old placements 'auto left|right|top|bottom'\n    let placement = position.match(/auto\\s(left|right|top|bottom|start|end)/)\n        ? position.split(' ')[1] || 'auto'\n        : position;\n    // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n    const matches = placement.match(/^(left|right|top|bottom|start|end)* ?(?!\\1)(left|right|top|bottom|start|end)?/);\n    if (matches) {\n        placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n    }\n    // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n    if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n        placement = 'auto';\n    }\n    placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n    const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n    return {\n        options: options || { modifiers: {} },\n        instance: {\n            target: targetElement,\n            host: hostElement,\n            arrow: void 0\n        },\n        offsets: {\n            target: targetOffset,\n            host: hostElPosition,\n            arrow: void 0\n        },\n        positionFixed: false,\n        placement,\n        placementAuto\n    };\n}\n\nfunction preventOverflow(data) {\n    var _a;\n    if (!isModifierEnabled(data.options, 'preventOverflow')) {\n        return data;\n    }\n    // NOTE: DOM access here\n    // resets the target Offsets's position so that the document size can be calculated excluding\n    // the size of the targetOffsets element itself\n    const transformProp = 'transform';\n    const targetStyles = data.instance.target.style; // assignment to help minification\n    const { top, left, [transformProp]: transform } = targetStyles;\n    targetStyles.top = '';\n    targetStyles.left = '';\n    targetStyles[transformProp] = '';\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    ((_a = data.options.modifiers.preventOverflow) === null || _a === void 0 ? void 0 : _a.boundariesElement) || 'scrollParent', false // positionFixed\n    );\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    targetStyles.top = top;\n    targetStyles.left = left;\n    targetStyles[transformProp] = transform;\n    const order = ['left', 'right', 'top', 'bottom'];\n    const check = {\n        primary(placement) {\n            var _a, _b, _c, _d;\n            let value = data.offsets.target[placement];\n            // options.escapeWithReference\n            if (((_a = data.offsets.target[placement]) !== null && _a !== void 0 ? _a : 0) < ((_b = boundaries[placement]) !== null && _b !== void 0 ? _b : 0)) {\n                value = Math.max((_c = data.offsets.target[placement]) !== null && _c !== void 0 ? _c : 0, (_d = boundaries[placement]) !== null && _d !== void 0 ? _d : 0);\n            }\n            return { [placement]: value };\n        },\n        secondary(placement) {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            const mainSide = placement === 'right' ? 'left' : 'top';\n            let value = data.offsets.target[mainSide];\n            // escapeWithReference\n            if (((_a = data.offsets.target[placement]) !== null && _a !== void 0 ? _a : 0) < ((_b = boundaries[placement]) !== null && _b !== void 0 ? _b : 0) && placement !== 'right') {\n                value = Math.min((_c = data.offsets.target[mainSide]) !== null && _c !== void 0 ? _c : 0, ((_d = boundaries[placement]) !== null && _d !== void 0 ? _d : 0) - data.offsets.target.height);\n            }\n            if (((_e = data.offsets.target[placement]) !== null && _e !== void 0 ? _e : 0) > ((_f = boundaries[placement]) !== null && _f !== void 0 ? _f : 0) && placement === 'right') {\n                value = Math.min((_g = data.offsets.target[mainSide]) !== null && _g !== void 0 ? _g : 0, ((_h = boundaries[placement]) !== null && _h !== void 0 ? _h : 0) - data.offsets.target.width);\n            }\n            return { [mainSide]: value };\n        }\n    };\n    order.forEach((placement) => {\n        const side = ['left', 'top', 'start'].indexOf(placement) !== -1 ? check['primary'] : check['secondary'];\n        data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), side(placement));\n    });\n    return data;\n}\n\nfunction shift(data) {\n    var _a;\n    const placement = data.placement;\n    const basePlacement = placement.split(' ')[0];\n    const shiftVariation = placement.split(' ')[1];\n    if (shiftVariation) {\n        const { host, target } = data.offsets;\n        const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        const side = isVertical ? 'left' : 'top';\n        const measurement = isVertical ? 'width' : 'height';\n        const shiftOffsets = {\n            start: { [side]: host[side] },\n            end: {\n                [side]: ((_a = host[side]) !== null && _a !== void 0 ? _a : 0) + host[measurement] - target[measurement]\n            }\n        };\n        data.offsets.target = Object.assign(Object.assign({}, target), {\n            [side]: (side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side])\n        });\n    }\n    return data;\n}\n\nclass Positioning {\n    position(hostElement, targetElement /*, round = true*/) {\n        return this.offset(hostElement, targetElement /*, false*/);\n    }\n    offset(hostElement, targetElement /*, round = true*/) {\n        return getReferenceOffsets(targetElement, hostElement);\n    }\n    positionElements(hostElement, targetElement, position, appendToBody, options) {\n        const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n        const _position = MapPlacementInToRL[position];\n        const data = initData(targetElement, hostElement, _position, options);\n        if (!data) {\n            return;\n        }\n        return chainOfModifiers.reduce((modifiedData, modifier) => modifier(modifiedData), data);\n    }\n}\nconst positionService = new Positioning();\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n    const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n    if (!data) {\n        return;\n    }\n    const offsets = getOffsets(data);\n    setStyles(targetElement, {\n        'will-change': 'transform',\n        top: '0px',\n        left: '0px',\n        transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n    }, renderer);\n    if (data.instance.arrow) {\n        setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n    }\n    updateContainerClass(data, renderer);\n}\n\nclass PositioningService {\n    constructor(ngZone, rendererFactory, platformId) {\n        this.update$$ = new Subject();\n        this.positionElements = new Map();\n        this.isDisabled = false;\n        if (isPlatformBrowser(platformId)) {\n            ngZone.runOutsideAngular(() => {\n                this.triggerEvent$ = merge(fromEvent(window, 'scroll', { passive: true }), fromEvent(window, 'resize', { passive: true }), of(0, animationFrameScheduler), this.update$$);\n                this.triggerEvent$.subscribe(() => {\n                    if (this.isDisabled) {\n                        return;\n                    }\n                    this.positionElements\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .forEach((positionElement) => {\n                        positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n                    });\n                });\n            });\n        }\n    }\n    position(options) {\n        this.addPositionElement(options);\n    }\n    get event$() {\n        return this.triggerEvent$;\n    }\n    disable() {\n        this.isDisabled = true;\n    }\n    enable() {\n        this.isDisabled = false;\n    }\n    addPositionElement(options) {\n        this.positionElements.set(_getHtmlElement(options.element), options);\n    }\n    calcPosition() {\n        this.update$$.next();\n    }\n    deletePositionElement(elRef) {\n        this.positionElements.delete(_getHtmlElement(elRef));\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n}\nPositioningService.ɵfac = function PositioningService_Factory(t) { return new (t || PositioningService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2), ɵngcc0.ɵɵinject(PLATFORM_ID)); };\nPositioningService.ɵprov = ɵɵdefineInjectable({ factory: function PositioningService_Factory() { return new PositioningService(ɵɵinject(NgZone), ɵɵinject(RendererFactory2), ɵɵinject(PLATFORM_ID)); }, token: PositioningService, providedIn: \"root\" });\nPositioningService.ctorParameters = () => [\n    { type: NgZone },\n    { type: RendererFactory2 },\n    { type: Number, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PositioningService, [{\n        type: Injectable,\n        args: [{ providedIn: 'root' }]\n    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.RendererFactory2 }, { type: Number, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }]; }, null); })();\nfunction _getHtmlElement(element) {\n    // it means that we got a selector\n    if (typeof element === 'string') {\n        return document.querySelector(element);\n    }\n    if (element instanceof ElementRef) {\n        return element.nativeElement;\n    }\n    return element !== null && element !== void 0 ? element : null;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { PlacementForBs5, Positioning, PositioningService, checkMargins, positionElements };\n\n"]},"metadata":{},"sourceType":"module"}